#!/usr/bin/env node

/**
 * niki — Deterministic process supervisor for AI agents.
 *
 * Wraps a child command (e.g. `claude -p`) and enforces:
 *   - Token budget (kill if exceeded)
 *   - Wall-clock timeout (kill if exceeded)
 *   - Tool-call rate limiting (kill if agent floods)
 *   - Diagnostics logging
 *
 * Usage:
 *   niki [options] -- <command> [args...]
 *   niki --budget 500000 --timeout 3600 -- claude -p "..." --verbose
 *
 * Security:
 *   - Never logs or exposes API tokens
 *   - Inherits env from parent (tokens stay in env, never in CLI args)
 *   - Diagnostics only contain counters, never message content
 */

import { spawn, execSync } from 'node:child_process';
import { createWriteStream, writeFileSync, mkdirSync, existsSync, readFileSync } from 'node:fs';
import { dirname, resolve } from 'node:path';
import { parseArgs } from 'node:util';

// --- Argument parsing ---

const SEPARATOR = process.argv.indexOf('--');
if (SEPARATOR === -1 || SEPARATOR === process.argv.length - 1) {
  console.error(`niki — deterministic agent supervisor

Usage: niki [options] -- <command> [args...]

Options:
  --budget <tokens>       Max total tokens (input+output) before SIGTERM (default: 1000000)
  --timeout <seconds>     Max wall-clock runtime before SIGTERM (default: 3600)
  --max-sends <n>         Max agentchat_send calls per minute (default: 10)
  --max-tool-calls <n>    Max total tool calls per minute (default: 30)
  --stall-timeout <secs>  Kill after N seconds of no output (default: 60, 0=disabled)
  --startup-timeout <s>   Longer stall timeout until first output (default: 180, 0=use stall-timeout)
  --dead-air-timeout <m>  Minutes of zero CPU + zero output before kill (default: 5, 0=disabled)
  --max-nudges <n>        Max stdin nudge attempts before kill on stall (default: 3)
  --log <file>            Write diagnostics log to file
  --state <file>          Write state JSON on exit (budget used, reason, etc.)
  --cooldown <seconds>    Grace period after SIGTERM before SIGKILL (default: 5)
  --abort-file <path>     Poll this file for external abort signal
  --poll-interval <ms>    Base poll interval in ms for abort file (default: 1000)

Examples:
  niki --budget 500000 -- claude -p "your prompt" --verbose
  niki --timeout 1800 --max-sends 5 -- claude -p "..." --model sonnet --verbose`);
  process.exit(1);
}

const nikiArgs = process.argv.slice(2, SEPARATOR);
const childCmd = process.argv[SEPARATOR + 1];
const childArgs = process.argv.slice(SEPARATOR + 2);

const { values: opts } = parseArgs({
  args: nikiArgs,
  options: {
    budget:          { type: 'string', default: '1000000' },
    timeout:         { type: 'string', default: '3600' },
    'max-sends':     { type: 'string', default: '10' },
    'max-tool-calls': { type: 'string', default: '30' },
    'stall-timeout': { type: 'string', default: '60' },
    'startup-timeout': { type: 'string', default: '180' },
    'dead-air-timeout': { type: 'string', default: '5' },
    'max-nudges':    { type: 'string', default: '3' },
    log:             { type: 'string' },
    state:           { type: 'string' },
    cooldown:        { type: 'string', default: '5' },
    'abort-file':    { type: 'string' },
    'poll-interval': { type: 'string', default: '1000' },
  },
});

const BUDGET        = parseInt(opts.budget, 10);
const TIMEOUT_S     = parseInt(opts.timeout, 10);
const MAX_SENDS     = parseInt(opts['max-sends'], 10);
const MAX_TOOL_CALLS = parseInt(opts['max-tool-calls'], 10);
const STALL_TIMEOUT_S = parseInt(opts['stall-timeout'], 10);
const STARTUP_TIMEOUT_S = parseInt(opts['startup-timeout'], 10);
const DEAD_AIR_TIMEOUT_M = parseFloat(opts['dead-air-timeout']);
const MAX_NUDGES    = parseInt(opts['max-nudges'], 10);
const COOLDOWN_S    = parseInt(opts.cooldown, 10);
const ABORT_FILE    = opts['abort-file'] ? resolve(opts['abort-file']) : null;
const POLL_INTERVAL = parseInt(opts['poll-interval'], 10);
const LOG_FILE      = opts.log;
const STATE_FILE    = opts.state;

// --- State ---

const state = {
  startedAt: new Date().toISOString(),
  pid: null,
  tokensIn: 0,
  tokensOut: 0,
  tokensTotal: 0,
  toolCalls: 0,
  sendCalls: 0,
  toolCallsThisMinute: 0,
  sendCallsThisMinute: 0,
  exitCode: null,
  exitSignal: null,
  killedBy: null,    // 'budget' | 'timeout' | 'rate-sends' | 'rate-tools' | 'abort' | 'stall' | 'dead-air' | null
  duration: 0,
  stallEvents: 0,
  nudges: 0,
  deadAirChecks: 0,
};

// Sliding window for per-minute rate limiting
const toolCallTimestamps = [];
const sendCallTimestamps = [];

// --- Logging ---

let logStream = null;
if (LOG_FILE) {
  mkdirSync(dirname(resolve(LOG_FILE)), { recursive: true });
  logStream = createWriteStream(resolve(LOG_FILE), { flags: 'a' });
}

function log(msg) {
  const line = `[${new Date().toISOString()}] ${msg}`;
  if (logStream) logStream.write(line + '\n');
  // Also write to stderr so supervisor can capture it
  process.stderr.write(`[niki] ${line}\n`);
}

function writeState() {
  if (!STATE_FILE) return;
  try {
    mkdirSync(dirname(resolve(STATE_FILE)), { recursive: true });
    // Never include env, tokens, or message content — only counters
    writeFileSync(resolve(STATE_FILE), JSON.stringify(state, null, 2) + '\n');
  } catch {
    // Best effort
  }
}

// --- Token parsing from stderr ---

// Claude --verbose outputs token usage in stderr. Patterns vary by version.
// We look for common patterns and extract numbers.
//
// Known patterns:
//   "input_tokens": 1234
//   "output_tokens": 567
//   tokens: { input: 1234, output: 567 }
//   Input tokens: 1234
//   Output tokens: 567

const TOKEN_PATTERNS = [
  // JSON-style: "input_tokens": 1234
  { regex: /"input_tokens"\s*:\s*(\d+)/g, field: 'in' },
  { regex: /"output_tokens"\s*:\s*(\d+)/g, field: 'out' },
  // Human-readable: Input tokens: 1234
  { regex: /Input tokens:\s*(\d+)/gi, field: 'in' },
  { regex: /Output tokens:\s*(\d+)/gi, field: 'out' },
];

function parseTokens(line) {
  for (const { regex, field } of TOKEN_PATTERNS) {
    regex.lastIndex = 0;
    let match;
    while ((match = regex.exec(line)) !== null) {
      const count = parseInt(match[1], 10);
      if (isNaN(count) || count <= 0) continue;
      if (field === 'in') {
        state.tokensIn = Math.max(state.tokensIn, count);
      } else {
        state.tokensOut = Math.max(state.tokensOut, count);
      }
      state.tokensTotal = state.tokensIn + state.tokensOut;
    }
  }
}

// --- Tool call detection from stderr ---

// Claude --verbose logs tool calls. We detect sends specifically.
const TOOL_CALL_PATTERN = /(?:Using tool|Tool call|tool_use).*?(\w+)/i;
const SEND_PATTERN = /agentchat_send/i;

function parseToolCall(line) {
  if (TOOL_CALL_PATTERN.test(line)) {
    const now = Date.now();
    state.toolCalls++;
    toolCallTimestamps.push(now);

    if (SEND_PATTERN.test(line)) {
      state.sendCalls++;
      sendCallTimestamps.push(now);
    }
  }
}

// --- Rate limit checking ---

function pruneWindow(timestamps) {
  const cutoff = Date.now() - 60_000; // 1 minute window
  while (timestamps.length > 0 && timestamps[0] < cutoff) {
    timestamps.shift();
  }
}

function checkRateLimits() {
  pruneWindow(toolCallTimestamps);
  pruneWindow(sendCallTimestamps);

  state.toolCallsThisMinute = toolCallTimestamps.length;
  state.sendCallsThisMinute = sendCallTimestamps.length;

  if (sendCallTimestamps.length > MAX_SENDS) {
    return 'rate-sends';
  }
  if (toolCallTimestamps.length > MAX_TOOL_CALLS) {
    return 'rate-tools';
  }
  return null;
}

// --- Kill logic ---

let child = null;
let killed = false;

function killChild(reason) {
  if (killed || !child) return;
  killed = true;
  state.killedBy = reason;
  log(`KILL — reason: ${reason} | tokens: ${state.tokensTotal}/${BUDGET} | sends: ${state.sendCallsThisMinute}/min | tools: ${state.toolCallsThisMinute}/min`);

  child.kill('SIGTERM');

  // Grace period, then SIGKILL
  setTimeout(() => {
    try {
      child.kill('SIGKILL');
    } catch {
      // Already dead
    }
  }, COOLDOWN_S * 1000);
}

// --- Prompt pattern detection ---

const PROMPT_PATTERNS = [
  /\(y\/n\)/i,
  /\[Y\/n\]/i,
  /\[y\/N\]/i,
  /\(yes\/no\)/i,
  /Do you want to trust/i,
  /Do you want to allow/i,
  /Press Enter to continue/i,
  /Are you sure/i,
];

function checkForPrompts(text) {
  for (const pattern of PROMPT_PATTERNS) {
    if (pattern.test(text)) {
      log(`PROMPT detected in stdout: ${text.trim().substring(0, 100)}`);
      state.stallEvents++;
      // Close stdin to dismiss the prompt
      closeStdin();
      return true;
    }
  }
  return false;
}

// --- CPU liveness sampling ---

// Reads cumulative CPU time (user+system) for a process tree.
// Returns total CPU milliseconds, or -1 if unavailable.
// On Linux: reads /proc/<pid>/stat (works in containers).
// On macOS: uses ps command as fallback.
let lastCpuMs = null;  // null = no prior sample taken yet

function sampleCpuMs(pid) {
  try {
    // Linux: /proc/<pid>/stat fields 14 (utime) and 15 (stime) in clock ticks
    const statPath = `/proc/${pid}/stat`;
    if (existsSync(statPath)) {
      const stat = readFileSync(statPath, 'utf8');
      // Fields are space-separated, but comm (field 2) can contain spaces/parens.
      // Find the closing paren, then split the rest.
      const afterComm = stat.substring(stat.lastIndexOf(')') + 2);
      const fields = afterComm.split(' ');
      // fields[11] = utime (index 13 in original), fields[12] = stime (index 14)
      const utime = parseInt(fields[11], 10) || 0;
      const stime = parseInt(fields[12], 10) || 0;
      // Also grab child times: fields[13] = cutime, fields[14] = cstime
      const cutime = parseInt(fields[13], 10) || 0;
      const cstime = parseInt(fields[14], 10) || 0;
      // Convert clock ticks to ms (typically 100 ticks/sec on Linux)
      const ticksPerSec = 100;
      return ((utime + stime + cutime + cstime) / ticksPerSec) * 1000;
    }

    // macOS / fallback: use ps to get cumulative CPU time
    const output = execSync(`ps -o cputime= -p ${pid} 2>/dev/null`, { encoding: 'utf8', timeout: 3000 }).trim();
    if (!output) return -1;
    // Format: HH:MM:SS or M:SS
    const parts = output.split(':').map(Number);
    if (parts.length === 3) return (parts[0] * 3600 + parts[1] * 60 + parts[2]) * 1000;
    if (parts.length === 2) return (parts[0] * 60 + parts[1]) * 1000;
    return -1;
  } catch {
    return -1;
  }
}

// Returns true if the child process has consumed CPU since the last sample.
function hasConsumedCpu(pid) {
  const cpuMs = sampleCpuMs(pid);
  if (cpuMs < 0) return true; // Can't measure → assume alive (safe default)

  const prev = lastCpuMs;
  lastCpuMs = cpuMs;

  // First sample — no delta yet, assume alive
  if (prev === null) return true;

  // If CPU time increased at all, process is doing work
  return cpuMs > prev;
}

// --- Dead air detection ---

let deadAirStart = null;   // Timestamp when dead air began (null = not in dead air)
let deadAirPollId = null;

function checkDeadAir() {
  if (killed || !child || DEAD_AIR_TIMEOUT_M <= 0) return;

  state.deadAirChecks++;
  const cpuActive = hasConsumedCpu(child.pid);
  const silenceSec = Math.round((Date.now() - lastOutputTime) / 1000);

  if (cpuActive) {
    // Process is working — reset dead air, let it cook
    if (deadAirStart) {
      log(`Dead air cleared — CPU active after ${Math.round((Date.now() - deadAirStart) / 1000)}s of silence`);
      deadAirStart = null;
    }
    return;
  }

  // Zero CPU + zero output
  if (!deadAirStart) {
    deadAirStart = Date.now();
    log(`Dead air started — zero CPU, ${silenceSec}s silence`);
  }

  const deadAirMin = (Date.now() - deadAirStart) / 60_000;
  if (deadAirMin >= DEAD_AIR_TIMEOUT_M) {
    log(`DEAD AIR — zero CPU + zero output for ${Math.round(deadAirMin)}min (threshold: ${DEAD_AIR_TIMEOUT_M}min)`);
    killChild('dead-air');
    return;
  }

  log(`Dead air check — zero CPU, ${Math.round(deadAirMin * 10) / 10}/${DEAD_AIR_TIMEOUT_M}min, ${silenceSec}s silence`);
}

// Poll interval: min(30s, threshold/3) — fast polls for short thresholds, 30s cap for production
const DEAD_AIR_POLL_MS = DEAD_AIR_TIMEOUT_M > 0
  ? Math.min(30_000, Math.max(2_000, (DEAD_AIR_TIMEOUT_M * 60_000) / 3))
  : 30_000;

function scheduleDeadAirPoll() {
  if (killed || DEAD_AIR_TIMEOUT_M <= 0) return;
  deadAirPollId = setTimeout(() => {
    checkDeadAir();
    if (!killed) scheduleDeadAirPoll();
  }, jitteredDelay(DEAD_AIR_POLL_MS));
}

// --- Stall detection ---

let stallTimer = null;
let nudgeCount = 0;
let stdinClosed = false;
let lastOutputTime = Date.now();
let gotFirstOutput = false;

function onChildOutput() {
  lastOutputTime = Date.now();
  // Reset dead air — got real output
  if (deadAirStart) {
    log(`Dead air cleared — received output after ${Math.round((Date.now() - deadAirStart) / 1000)}s`);
    deadAirStart = null;
  }
  if (!gotFirstOutput) {
    gotFirstOutput = true;
    log(`First output received after ${Math.round((Date.now() - new Date(state.startedAt).getTime()) / 1000)}s — switching to stall-timeout=${STALL_TIMEOUT_S}s`);
  }
  resetStallTimer();
}

function currentStallTimeout() {
  // Use startup timeout until first output, then normal stall timeout
  if (!gotFirstOutput && STARTUP_TIMEOUT_S > 0) return STARTUP_TIMEOUT_S;
  return STALL_TIMEOUT_S;
}

function resetStallTimer() {
  if (stallTimer) clearTimeout(stallTimer);
  const timeout = currentStallTimeout();
  if (killed || timeout <= 0) return;
  stallTimer = setTimeout(onStallDetected, timeout * 1000);
}

function closeStdin() {
  if (stdinClosed || !child) return;
  stdinClosed = true;
  try { child.stdin.end(); } catch { /* already closed */ }
  log('Stdin: closed (EOF)');
}

function onStallDetected() {
  if (killed) return;
  state.stallEvents++;
  const silence = Math.round((Date.now() - lastOutputTime) / 1000);
  log(`STALL — no output for ${silence}s (nudges: ${nudgeCount}/${MAX_NUDGES})`);

  // Escalation: close stdin → nudge → check CPU → kill
  if (!stdinClosed) {
    closeStdin();
    resetStallTimer();
    return;
  }

  if (nudgeCount < MAX_NUDGES && !child.stdin.writableEnded) {
    nudgeCount++;
    state.nudges = nudgeCount;
    log(`Stall nudge #${nudgeCount}`);
    resetStallTimer();
    return;
  }

  // If dead air detection is enabled, defer kill to the dead air poller.
  // Only stall-kill if we can confirm zero CPU, or if dead air is disabled.
  if (DEAD_AIR_TIMEOUT_M > 0 && child) {
    const cpuActive = hasConsumedCpu(child.pid);
    if (cpuActive) {
      log(`Stall deferred — process has CPU activity, deferring to dead-air detection`);
      resetStallTimer();
      return;
    }
  }

  killChild('stall');
}

// --- Spawn child process ---

log(`Starting: ${childCmd} ${childArgs.join(' ').substring(0, 100)}...`);
log(`Budget: ${BUDGET} tokens | Timeout: ${TIMEOUT_S}s | Startup: ${STARTUP_TIMEOUT_S}s | Stall: ${STALL_TIMEOUT_S}s | Dead air: ${DEAD_AIR_TIMEOUT_M}min | Max sends: ${MAX_SENDS}/min | Max tools: ${MAX_TOOL_CALLS}/min`);

child = spawn(childCmd, childArgs, {
  stdio: ['pipe', 'pipe', 'pipe'],  // All piped: niki controls stdin, monitors stdout+stderr
  env: process.env,  // Inherit env (tokens stay in env, never logged)
});

state.pid = child.pid;

// Close stdin immediately — claude -p should never need interactive input.
// This prevents blocking on trust prompts, permission prompts, or stdin reads.
closeStdin();

// --- Monitor stdout ---

child.stdout.on('data', (chunk) => {
  // Forward to our stdout (preserves runner's | tee pipeline)
  process.stdout.write(chunk);
  onChildOutput();
  checkForPrompts(chunk.toString());
});

// --- Monitor stderr ---

let stderrBuffer = '';

child.stderr.on('data', (chunk) => {
  const text = chunk.toString();

  // Always forward stderr to our stderr (so supervisor captures it)
  process.stderr.write(chunk);
  onChildOutput();

  // Buffer and parse line by line
  stderrBuffer += text;
  const lines = stderrBuffer.split('\n');
  stderrBuffer = lines.pop(); // Keep incomplete last line in buffer

  for (const line of lines) {
    parseTokens(line);
    parseToolCall(line);

    // Check budget
    if (state.tokensTotal > BUDGET) {
      killChild('budget');
      return;
    }

    // Check rate limits
    const rateViolation = checkRateLimits();
    if (rateViolation) {
      killChild(rateViolation);
      return;
    }
  }
});

// Start stall detection
if (STALL_TIMEOUT_S > 0 || STARTUP_TIMEOUT_S > 0) {
  log(`Stall detection: startup-timeout=${STARTUP_TIMEOUT_S}s, stall-timeout=${STALL_TIMEOUT_S}s, max-nudges=${MAX_NUDGES}`);
  resetStallTimer();
}

// Start dead air detection
if (DEAD_AIR_TIMEOUT_M > 0) {
  log(`Dead air detection: ${DEAD_AIR_TIMEOUT_M}min threshold, ${Math.round(DEAD_AIR_POLL_MS / 1000)}s poll interval`);
  scheduleDeadAirPoll();
}

// --- Abort file polling (with jitter) ---

let abortPollId = null;

function jitteredDelay(base) {
  // ±30% jitter
  const jitter = base * 0.3;
  return base + (Math.random() * 2 * jitter - jitter);
}

function scheduleAbortPoll() {
  if (!ABORT_FILE || killed) return;
  abortPollId = setTimeout(() => {
    if (killed) return;
    if (existsSync(ABORT_FILE)) {
      log(`Abort file detected: ${ABORT_FILE}`);
      killChild('abort');
      return;
    }
    scheduleAbortPoll();
  }, jitteredDelay(POLL_INTERVAL));
}

if (ABORT_FILE) {
  log(`Abort file: ${ABORT_FILE} (poll: ${POLL_INTERVAL}ms ±30% jitter)`);
  scheduleAbortPoll();
}

// --- Timeout ---

const timeoutId = setTimeout(() => {
  killChild('timeout');
}, TIMEOUT_S * 1000);

// --- Clean exit ---

child.on('exit', (code, signal) => {
  clearTimeout(timeoutId);
  if (stallTimer) clearTimeout(stallTimer);
  if (abortPollId) clearTimeout(abortPollId);
  if (deadAirPollId) clearTimeout(deadAirPollId);
  state.exitCode = code;
  state.exitSignal = signal;
  state.duration = Math.round((Date.now() - new Date(state.startedAt).getTime()) / 1000);

  state.gotFirstOutput = gotFirstOutput;
  log(`Exit — code: ${code} signal: ${signal} | tokens: ${state.tokensTotal} | tools: ${state.toolCalls} | sends: ${state.sendCalls} | duration: ${state.duration}s | output: ${gotFirstOutput}${state.killedBy ? ` | killed: ${state.killedBy}` : ''}`);
  writeState();

  if (logStream) logStream.end();
  process.exit(code ?? 1);
});

// --- Signal forwarding ---

for (const sig of ['SIGINT', 'SIGTERM']) {
  process.on(sig, () => {
    log(`Received ${sig}, forwarding to child`);
    if (child) child.kill(sig);
  });
}
